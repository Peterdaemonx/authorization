package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"strings"
	"time"

	"golang.org/x/tools/go/packages"

	"github.com/dave/jennifer/jen"
)

func main() {
	inType := flag.String("in", "", "Name of the interface to wrap")
	outType := flag.String("out", "", "Name of the struct that wraps the interface")
	flag.Parse()

	log.Printf("Wrap %s with %s", *inType, *outType)

	inPkg, inIface, err := splitSourceType(*inType)
	if err != nil {
		failErr(err)
	}

	pkg := loadPackage(inPkg)

	iface := pkg.Types.Scope().Lookup(inIface)
	if iface == nil {
		failErr(fmt.Errorf("%s not found in declared types of %s", inIface, pkg))
	}

	if _, ok := iface.(*types.TypeName); !ok {
		failErr(fmt.Errorf("%v is not a named type", iface))
	}

	ifaceType, ok := iface.Type().Underlying().(*types.Interface)
	if !ok {
		failErr(fmt.Errorf("type %v is not an interface", iface))
	}

	f := jen.NewFile("timingwrappers")
	f.PackageComment("Code generated by timing/wrappers/generate, DO NOT EDIT.")
	f.PackageComment("Generated on " + time.Now().Format("Mon Jan 2 15:04 2006"))
	f.Type().Id(*outType).Struct(
		jen.Id("Base").Qual(inPkg, inIface),
	)

	ms := types.NewMethodSet(ifaceType)

	for i := 0; i < ms.Len(); i++ {
		meth := ms.At(i).Obj()
		methType := meth.Type().(*types.Signature)
		methRets := methType.Results()
		methParams := methType.Params()

		params := []jen.Code{}
		paramPass := []jen.Code{}

		for j := 0; j < methParams.Len(); j++ {
			methParam := methParams.At(j)
			mpPkg, mpName, err := splitSourceType(methParam.Type().String())
			if err == nil {
				params = append(params, jen.Id(methParam.Name()).Qual(unslice(mpPkg), mpName))
			} else {
				params = append(params, jen.Id(methParam.Name()).Id(methParam.Type().String()))
			}

			paramPass = append(paramPass, jen.Id(methParam.Name()))
		}

		returns := []jen.Code{}
		for j := 0; j < methRets.Len(); j++ {
			methRet := methRets.At(j)
			mrPkg, mrName, err := splitSourceType(methRet.Type().String())

			if err == nil {
				returns = append(returns, unsliceQual(mrPkg, mrName))
			} else {
				returns = append(returns, jen.Id(methRet.Type().String()))
			}
		}

		f.Func().Params(
			jen.Id("w").Id(*outType),
		).Id(meth.Name()).
			Params(params...).
			Parens(jen.List(returns...)).
			Block(
				jen.Qual("gitlab.cmpayments.local/creditcard/authorization/internal/timing", "Start").Call(
					jen.Id("ctx"), jen.Lit(*outType+"."+meth.Name()),
				),
				jen.Defer(),
				jen.Qual("gitlab.cmpayments.local/creditcard/authorization/internal/timing", "Stop").Call(
					jen.Id("ctx"), jen.Lit(*outType+"."+meth.Name()),
				),
				jen.Return(
					jen.Id("w").Dot("Base").Dot(meth.Name()).Call(jen.List(paramPass...)),
				),
			)
	}

	err = f.Save(strings.ToLower(*outType) + ".go")
	if err != nil {
		failErr(err)
	}
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func splitSourceType(sourceType string) (string, string, error) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		return "", "", fmt.Errorf(`expected qualified type as "pkg/path.MyType", not "%s"`, sourceType)
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName, nil
}

func unslice(pkg string) string {
	return strings.TrimPrefix(pkg, "[]")
}

func unsliceQual(pkg, typ string) *jen.Statement {
	if !strings.HasPrefix(pkg, "[]") {
		return jen.Qual(pkg, typ)
	}

	return jen.Index().Qual(unslice(pkg), typ)
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
